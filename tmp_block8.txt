                if (!this.boss || !this.boss.active) return;
                // Horizontal sweep with bounce
                // Maintain a constant Y to avoid drift from any physics side-effects
                // Early finish if HP already empty (edge case)
                if (this.bossHp <= 0) { this.killBoss(); return; }
                // Gentle vertical bobbing to vary movement
                this.boss.y = this.bossHomeY + Math.sin(time * 0.004) * 18;
                // Horizontal movement handled by tween; no manual increment
                // Clamp and bounce â€“ prevents drifting off-screen due to large deltas
                // (tween controls horizontal range)
                // Horizontal movement handled by tween; keep physics hitbox aligned
                if (this.bossHit) {
                    this.bossHit.setPosition(this.boss.x, this.boss.y);
                    if (this.bossHit.body && this.bossHit.body.updateFromGameObject) this.bossHit.body.updateFromGameObject();
                }
                
                
                // Occasionally retarget the tween to reduce predictability
                if (!this.bossNextRetargetAt) this.bossNextRetargetAt = time + 3500;
                if (time >= this.bossNextRetargetAt) {
                    const cur = this.boss.x;
                    let to = Phaser.Math.Between(80, 720);
                    // Ensure a reasonable travel distance
                    if (Math.abs(to - cur) < 100) {
                        to = Phaser.Math.Clamp(cur + (to < cur ? -160 : 160), 80, 720);
                    }
                    const dur = Phaser.Math.Between(1600, 2600);
                    if (this.bossTween) { this.bossTween.stop(); this.bossTween = null; }
                    this.bossTween = this.tweens.add({ targets: this.boss, x: { to }, duration: dur, yoyo: true, repeat: -1, ease: 'Sine.inOut' });
                    this.bossNextRetargetAt = time + Phaser.Math.Between(3500, 6000);
